/*!
 * This file is part of the "malle" library
 * Copyright 2021, 2022 Nicolas CARPi @ Deltablot
 * License MIT
 * https://github.com/deltablot/malle
 */
export var InputType;
(function (InputType) {
    InputType["Color"] = "color";
    InputType["Date"] = "date";
    InputType["Datetime"] = "datetime-local";
    InputType["Email"] = "email";
    InputType["Number"] = "number";
    InputType["Select"] = "select";
    InputType["Text"] = "text";
    InputType["Textarea"] = "textarea";
    InputType["Time"] = "time";
    InputType["Url"] = "url";
})(InputType || (InputType = {}));
export var EventType;
(function (EventType) {
    EventType["Click"] = "click";
    EventType["Mouseenter"] = "mouseenter";
    EventType["Mouseover"] = "mouseover";
})(EventType || (EventType = {}));
export var Action;
(function (Action) {
    Action["Submit"] = "submit";
    Action["Cancel"] = "cancel";
    Action["Ignore"] = "ignore";
})(Action || (Action = {}));
export class Malle {
    constructor(options) {
        this.opt = this.normalizeOptions(options);
        this.debug(`Options: ${JSON.stringify(this.opt)}`);
        if (this.opt.listenNow) {
            this.listen();
        }
        this.innerFun = this.opt.returnedValueIsTrustedHtml ? 'innerHTML' : 'innerText';
    }
    normalizeOptions(options) {
        const defaultOptions = {
            after: undefined,
            before: undefined,
            cancel: '',
            cancelClasses: [],
            formClasses: [],
            inputClasses: [],
            debug: false,
            event: EventType.Click,
            focus: true,
            fun: () => new Error('No user function defined!'),
            inputType: InputType.Text,
            listenNow: false,
            listenOn: '[data-malleable="true"]',
            onBlur: Action.Submit,
            onEdit: undefined,
            onEnter: Action.Submit,
            onEscape: Action.Cancel,
            placeholder: '',
            requireDiff: true,
            returnedValueIsTrustedHtml: false,
            selectOptions: [],
            selectOptionsValueKey: 'value',
            selectOptionsTextKey: 'text',
            submit: '',
            submitClasses: [],
            tooltip: '',
            inputValue: '',
        };
        return Object.assign(defaultOptions, options);
    }
    listen() {
        document.querySelectorAll(this.opt.listenOn)
            .forEach((el) => {
            const opt = this.opt;
            opt.listenNow = false;
            const m = new Malle(opt);
            el.addEventListener(this.opt.event, m.process.bind(m));
            el.style.cursor = 'pointer';
            if (this.opt.tooltip) {
                el.title = this.opt.tooltip;
            }
        });
        this.debug(`malle now listening for ${this.opt.event} events on elements with selector: ${this.opt.listenOn}`);
        return this;
    }
    debug(msg) {
        if (this.opt.debug) {
            console.debug(msg);
        }
    }
    submit(event) {
        event.preventDefault();
        if (!this.form.reportValidity()) {
            return false;
        }
        if (this.opt.requireDiff) {
            const newValue = this.opt.inputType === InputType.Select
                ? this.input.options[this.input.selectedIndex].text
                : this.input.value;
            if (this.original.innerText === newValue) {
                this.debug('original value is same as new value, reverting without calling fun');
                this.form.replaceWith(this.original);
                return false;
            }
        }
        this.opt.fun.call(this, this.input.value, this.original, event, this.input).then((value) => {
            this.original[this.innerFun] = this.opt.inputType === InputType.Select ? this.input.options[this.input.selectedIndex].text : value;
            this.form.replaceWith(this.original);
            if (typeof this.opt.after === 'function') {
                return this.opt.after(this.original, event, value);
            }
        });
        return true;
    }
    cancel(event) {
        event.preventDefault();
        this.debug(event.toString());
        this.debug('reverting to original element');
        this.form.replaceWith(this.original);
        return true;
    }
    handleBlur(event) {
        let blurAction = this.opt.onBlur;
        if (this.original.dataset.maBlur) {
            blurAction = this.original.dataset.maBlur;
        }
        if (blurAction === Action.Ignore) {
            return;
        }
        this[blurAction](event);
    }
    handleKeypress(event) {
        if (this.opt.inputType === InputType.Textarea) {
            return false;
        }
        if (event.key === 'Enter') {
            let enterAction = this.opt.onEnter;
            if (this.original.dataset.maEnter) {
                enterAction = this.original.dataset.maEnter;
            }
            if (enterAction === Action.Ignore) {
                event.preventDefault();
                return;
            }
            this[enterAction](event);
            return;
        }
        if (event.key === 'Escape') {
            let escAction = this.opt.onEscape;
            if (this.original.dataset.maEscape) {
                escAction = this.original.dataset.maEscape;
            }
            if (escAction === Action.Ignore) {
                event.preventDefault();
                return;
            }
            this[escAction](event);
        }
    }
    getInput() {
        let inputElement = 'input';
        if (this.opt.inputType === InputType.Textarea) {
            inputElement = 'textarea';
        }
        if (this.opt.inputType === InputType.Select) {
            inputElement = 'select';
        }
        const input = document.createElement(inputElement);
        if (this.opt.inputType !== InputType.Textarea && this.opt.inputType !== InputType.Select) {
            input.type = this.opt.inputType;
        }
        if (this.original.dataset.maType) {
            input.type = this.original.dataset.maType;
        }
        this.opt.inputClasses.forEach(cl => {
            input.classList.add(cl);
        });
        let value;
        if (this.opt.inputValue) {
            value = this.opt.inputValue;
        }
        if (this.original.dataset.maInputValue) {
            value = this.original.dataset.maInputValue;
        }
        if (!value) {
            value = this.original.innerText;
        }
        input.value = value;
        if (this.opt.placeholder) {
            input.placeholder = this.opt.placeholder;
        }
        if (this.original.dataset.maPlaceholder) {
            input.placeholder = this.original.dataset.maPlaceholder;
        }
        if (this.opt.inputType === InputType.Select) {
            Promise.resolve(this.opt.selectOptions).then(o => {
                o.forEach(o => {
                    var _a;
                    const option = document.createElement('option');
                    option.value = o[this.opt.selectOptionsValueKey];
                    option[this.innerFun] = o[this.opt.selectOptionsTextKey];
                    option.selected = ((_a = o.selected) !== null && _a !== void 0 ? _a : false) || this.original[this.innerFun] === o[this.opt.selectOptionsTextKey];
                    input.appendChild(option);
                });
            });
        }
        input.addEventListener('keydown', this.handleKeypress.bind(this));
        if (this.opt.submit === '' && this.opt.cancel === '') {
            input.addEventListener('blur', this.handleBlur.bind(this));
        }
        return input;
    }
    process(event) {
        this.debug('Event triggered:');
        this.debug(event.toString());
        const el = event.currentTarget;
        this.original = el;
        if (typeof this.opt.before === 'function') {
            if (this.opt.before(this.original, event) !== true) {
                return;
            }
        }
        const form = document.createElement('form');
        this.opt.formClasses.forEach(cl => {
            form.classList.add(cl);
        });
        const input = this.getInput();
        form.appendChild(input);
        [Action.Submit, Action.Cancel].forEach(action => {
            if (this.opt[action]) {
                const btn = document.createElement('button');
                btn.innerText = this.opt[action];
                const actionClasses = action + 'Classes';
                this.opt[actionClasses].forEach((cl) => {
                    btn.classList.add(cl);
                });
                btn.addEventListener('click', this[action].bind(this));
                form.appendChild(btn);
            }
        });
        el.replaceWith(form);
        if (this.opt.focus) {
            input.focus();
        }
        this.input = input;
        this.form = form;
        if (typeof this.opt.onEdit === 'function') {
            this.opt.onEdit(this.original, event, this.input);
        }
    }
}
//# sourceMappingURL=main.js.map